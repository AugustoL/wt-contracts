const abiDecoder = require('abi-decoder');
const web3Abi = require('web3-eth-abi');
const simulateCrowdsale = require('./simulateCrowdsale');
const lif2LifWei = require('./misc').lif2LifWei;
const contract = require('truffle-contract');

const Unit = artifacts.require('Unit.sol');
const UnitType = artifacts.require('UnitType.sol');
const UnitInterface = artifacts.require('Unit_Interface.sol');
const HotelInterface = artifacts.require('Hotel_Interface.sol');
const WTIndex = artifacts.require('WTIndex.sol');
const LifTokenData = require("@windingtree/lif-token/build/contracts/LifToken.json");
const LifToken = contract(LifTokenData);

abiDecoder.addABI(UnitInterface._json.abi);
abiDecoder.addABI(LifToken._json.abi);
abiDecoder.addABI(HotelInterface._json.abi);
abiDecoder.addABI(WTIndex._json.abi);
/**
 * A library of helpers that spin up various privateCall / booking interactions.
 */
function getERC827tokenOverridingMethodData(methodName, parameters) {
  const methodAbi = LifToken._json.abi.filter((n) => n.name === methodName && n.inputs.length === parameters.length).pop();
  if (! methodAbi) {
    throw Error("Method not found on LifToken, maybe you are using an invalid signature?");
  }
  return web3Abi.encodeFunctionCall(methodAbi, parameters);
}

/**
 * Executes a beginCall booking
 * @param  {Instance} hotel            Hotel instance that inherits from PrivateCall
 * @param  {Instance} unit             Unit instance being booked
 * @param  {Address}  client           Address of the person making a booking
 * @param  {Number}   fromDay          Day after 01-01-1970 booking starts
 * @param  {Number}   daysAmount       Number of days to book for
 * @param  {Number}   price            Default LifToken price ?
 * @param  {String}   tokenOp          'approve' || 'transfer' || 'transferFrom'
 * @param  {String}   bookOp           'book' || 'bookWithLif'
 * @param  {Array}    accounts         The truffle contract accounts
 * @param  {Object}   options          flags that trigger various error conditions in the call seq.
 * @return {Object}
 * @example
 *   const result = {
 *
 *     token,               // LifToken instance generated by simulateCrowdsale
 *     clientInitialBalance // clients token balance after crowdsale
 *     hotelInitialBalance  // calling contracts token balance after crowdsale (typically: 0);
 *     bookData,            // `book` call data
 *     beginCallData,       // `beginCall` call data
 *     events,              // All abi-decoded events generated by the token call
 *     hash,                // dataHash of the call pending at `beginCall`
 *     userInfo,            // hex private data to the begin call: useful for testing error cases
 *     value                // number value of approval or transfer: 10e9
 *
 *   } = await help.runBeginCall(hotel, unit, augusto, 60, 5, 1, 'approve', accounts, lengthData)
 */
async function runBeginCall(
  hotel,
  unit,
  client,
  fromDay,
  daysAmount,
  price,
  tokenOp,
  bookOp,
  accounts,
  options
) {
  const wtIndex = await WTIndex.at(await hotel.owner());

  // Options: userInfo?
  let userInfo;
  (!options || options && !options.userInfo)
    ? userInfo = web3.toHex('user info')
    : userInfo = options.userInfo;

  // Options: unit price?
  if (!options || options && !options.keepPreviousHotel) {
    const unitTypeName = await unit.unitType();
    const unitType = await UnitType.at(await hotel.unitTypes(unitTypeName));
    const setPriceData = unitType.contract.setDefaultLifPrice.getData(price);
    const callUnitTypeData = hotel.contract.callUnitType.getData(unitTypeName, setPriceData);
    await wtIndex.callHotel(0, callUnitTypeData, {from: (await hotel.manager())});
  }

  // Options: require confirmation?
  if(options && options.requireConfirmation) {
    const changeConfirmationData = hotel.contract.changeConfirmation.getData(true);
    await wtIndex.callHotel(0, changeConfirmationData, {from: (await hotel.manager())});
  }

  // Options: approval value?
  let value;
  (!options || options && options.approvalValue === undefined)
    ? value = await hotel.getLifCost(unit.address, fromDay, daysAmount)
    : value = options.approvalValue

  // Options: zombie unit?
  if (options && options.badUnit){
    unit = await Unit.new(hotel.address, web3.toHex('BASIC_ROOM'), {from: accounts[5]});
  }

  // Run crowdsale
  const crowdsale = await simulateCrowdsale(100000000000, [40,30,20,10,0], accounts, 1);
  LifToken.setProvider(web3.currentProvider);
  const token = await LifToken.at(await crowdsale.token.call());
  await wtIndex.setLifToken(token.address);

  const hotelInitialBalance = await token.balanceOf(hotel.address);
  const clientInitialBalance = await token.balanceOf(client);

  // Compose token call
  const bookData = {
    'bookWithLif': hotel.contract.bookWithLif.getData(unit.address, client, fromDay, daysAmount),
    'book': hotel.contract.book.getData(unit.address, client, fromDay, daysAmount)
  }
  const beginCallData = hotel.contract.beginCall.getData(bookData[bookOp], userInfo);

  // See https://github.com/trufflesuite/truffle/issues/569, we have to make a workaround with web3
  // for overloaded methods with the same name but different signatures
  const tokenOpCall = async (methodName, parameters) => {
    let txData = {
      from: client,
      to: token.address,
      data: getERC827tokenOverridingMethodData(methodName, parameters),
      value: 0,
    };
    var gas = await web3.eth.estimateGas(txData);
    txData.gas = Math.round(gas * 1.5);
    const txHash = await web3.eth.sendTransaction(txData);
    return await web3.eth.getTransactionReceipt(txHash);
  };
  const tokenOpCalls = {
    'approve':      async () => await tokenOpCall('approve', [hotel.address, value, beginCallData]),
    'transfer':     async () => await tokenOpCall('transfer', [hotel.address, value, beginCallData]),
    'transferFrom': async () => await tokenOpCall('approve', [hotel.address, receiver, value, beginCallData]),
  };

  // Execute
  let events;
  let callStarted;
  let dataHashTopic;
  let success = false;
  let txReceipt;

  try {
    txReceipt = await tokenOpCalls[tokenOp]();
    events = abiDecoder.decodeLogs(txReceipt.logs);
    callStarted = events.filter(item => item && item.name === 'CallStarted')[0];
    dataHashTopic = callStarted.events.filter(item => item.name === 'dataHash')[0];
    success = true;
  } catch (e) {
    success = false;
  }

  return {
    userInfo: userInfo,
    value: value,
    token: token,
    hotelInitialBalance: hotelInitialBalance,
    clientInitialBalance: clientInitialBalance,
    bookData: bookData[bookOp],
    beginCallData: beginCallData,
    events: events,
    hash: dataHashTopic ? dataHashTopic.value : null,
    success: success
  }
}

/**
 * Executes a continueCall
 * @param  {Instance} index        WTIndex instance
 * @param  {Instance} hotel        Hotel instance
 * @param  {Address}  caller       Address of the contract that inherits from PrivateCall
 * @param  {Address}  hotelAccount Sender of the `callHotel` transaction
 * @param  {Bytes32}  hash         CallStarted dataHash value
 * @return {Object}
 * @example
 *   const result = {
 *     events,       // All abi-decoded events generated by the token call
 *   } = await help.runContinueCall(wtIndex, wtHotel, unit, hotelAccount, hash)
 */
async function runContinueCall(index, hotel, hotelAccount, hash){
  const _continue = hotel.contract.continueCall.getData(hash);
  const tx = await index.callHotel(0, _continue, {from: hotelAccount});
  const events = abiDecoder.decodeLogs(tx.receipt.logs);
  return {
    events: events
  }
}

module.exports = {
  runBeginCall: runBeginCall,
  runContinueCall: runContinueCall
}
